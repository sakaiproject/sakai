<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_04) on Thu Jun 30 23:33:49 BST 2005 -->
<TITLE>
jdbcPreparedStatement (HSQLDB 1.8.0 API)
</TITLE>

<META NAME="keywords" CONTENT="org.hsqldb.jdbc.jdbcPreparedStatement class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../hsqldbstylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="jdbcPreparedStatement (HSQLDB 1.8.0 API)";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/jdbcPreparedStatement.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/hsqldb/jdbc/jdbcParameterMetaData.html" title="class in org.hsqldb.jdbc"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/hsqldb/jdbc/jdbcResultSet.html" title="class in org.hsqldb.jdbc"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="jdbcPreparedStatement.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.hsqldb.jdbc</FONT>
<BR>
Class jdbcPreparedStatement</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by"><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html" title="class in org.hsqldb.jdbc">org.hsqldb.jdbc.jdbcStatement</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by"><B>org.hsqldb.jdbc.jdbcPreparedStatement</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.sql.PreparedStatement, java.sql.Statement</DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../org/hsqldb/jdbc/jdbcCallableStatement.html" title="class in org.hsqldb.jdbc">jdbcCallableStatement</A></DD>
</DL>
<HR>
<DL>
<DT>public class <B>jdbcPreparedStatement</B><DT>extends <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html" title="class in org.hsqldb.jdbc">jdbcStatement</A><DT>implements java.sql.PreparedStatement</DL>

<P>
<!-- start generic documentation -->

 An object that represents a precompiled SQL statement. <p>

 An SQL statement is precompiled and stored in a
 <code>PreparedStatement</code> object. This object can then be used to
 efficiently execute this statement multiple times.

 <P><B>Note:</B> The setter methods (<code>setShort</code>,
 <code>setString</code>, and so on) for setting IN parameter values
 must specify types that are compatible with the defined SQL type of
 the input parameter. For instance, if the IN parameter has SQL type
 <code>INTEGER</code>, then the method <code>setInt</code> should be
 used. <p>

 If arbitrary parameter type conversions are required, the method
 <code>setObject</code> should be used with a target SQL type.
 <P>
 In the following example of setting a parameter, <code>con</code>
 represents an active connection:
 <PRE>
 PreparedStatement pstmt = con.prepareStatement("UPDATE EMPLOYEES
                               SET SALARY = ? WHERE ID = ?");
 pstmt.setBigDecimal(1, 153833.00)
 pstmt.setInt(2, 110592)
 </PRE> <p>
 <!-- end generic documentation -->
 <!-- start Release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Starting with HSQLDB 1.7.2, jdbcPreparedStatement objects are backed by
 a true compiled parameteric representation. Hence, there are now significant
 performance gains to be had by using a jdbcPreparedStatement object in
 preference to a jdbcStatement object, if a short-running SQL statement is
 to be executed more than a small number of times. <p>

 Please note, however, that 1.7.2 does not yet provide a sophisticated
 internal statement pooling facility.  For this reason, the observation
 above is guaranteed to apply only under certain use patterns. <p>

 Specifically, when it can be otherwise avoided, it is to be considered poor
 practice to fully prepare (construct), parameterize, execute, fetch and
 close a jdbcPreparedStatement object for each execution cycle. Indeed, under
 HSQLDB 1.7.2, this practice is likely to be noticably <em>less</em>
 performant for short-running statements than the equivalent process using
 jdbcStatement objects, albeit far more convenient, less error prone and
 certainly much less resource-intensive, especially when large binary and
 character values are involved, due to the optimized parameterization
 facility. <p>

 Instead, when developing an application that is not totally oriented toward
 the execution of ad hoc SQL, it is recommended to expend some effort toward
 identifing the SQL statements that are good candidates for regular reuse and
 adapting the structure of the application accordingly. Often, this is done
 by recording the text of candidate SQL statements in an application resource
 object (which has the nice side-benefit of isolating and hiding differences
 in SQL dialects across different drivers) and caching for possible reuse the
 PreparedStatement objects derived from the recorded text. <p>

 <b>Multi thread use:</b> <p>

 A PreparedStatement object is stateful and should not normally be shared
 by multiple threads. If it has to be shared, the calls to set the
 parameters, calls to add batch statements, the execute call and any
 post-execute calls should be made within a block synchronized on the
 PreparedStatement Object.<p>

 <b>JRE 1.1.x Notes:</b> <p>

 In general, JDBC 2 support requires Java 1.2 and above, and JDBC3 requires
 Java 1.4 and above. In HSQLDB, support for methods introduced in different
 versions of JDBC depends on the JDK version used for compiling and building
 HSQLDB.<p>

 Since 1.7.0, it is possible to build the product so that
 all JDBC 2 methods can be called while executing under the version 1.1.x
 <em>Java Runtime Environment</em><sup><font size="-2">TM</font></sup>.
 However, in addition to requiring explicit casts to the org.hsqldb.jdbcXXX
 interface implementations, some of these method calls require
 <code>int</code> values that are defined only in the JDBC 2 or greater
 version of
 <a href="http://java.sun.com/j2se/1.4/docs/api/java/sql/ResultSet.html">
 <code>ResultSet</code></a> interface.  For this reason, when the
 product is compiled under JDK 1.1.x, these values are defined in
 <A HREF="../../../org/hsqldb/jdbc/jdbcResultSet.html" title="class in org.hsqldb.jdbc"><CODE>jdbcResultSet</CODE></A>.<p>

 In a JRE 1.1.x environment, calling JDBC 2 methods that take or return the
 JDBC2-only <code>ResultSet</code> values can be achieved by referring
 to them in parameter specifications and return value comparisons,
 respectively, as follows: <p>

 <pre class="JavaCodeExample">
 jdbcResultSet.FETCH_FORWARD
 jdbcResultSet.TYPE_FORWARD_ONLY
 jdbcResultSet.TYPE_SCROLL_INSENSITIVE
 jdbcResultSet.CONCUR_READ_ONLY
 // etc.
 </pre>

 However, please note that code written in such a manner will not be
 compatible for use with other JDBC 2 drivers, since they expect and use
 <code>ResultSet</code>, rather than <code>jdbcResultSet</code>.  Also
 note, this feature is offered solely as a convenience to developers
 who must work under JDK 1.1.x due to operating constraints, yet wish to
 use some of the more advanced features available under the JDBC 2
 specification.<p>

 (fredt@users)<br>
 (boucherb@users)
 </div>
 <!-- end Release-specific documentation -->
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>boucherb@users, fredt@users</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/jdbcConnection.html#prepareStatement(java.lang.String)"><CODE>jdbcConnection.prepareStatement(java.lang.String)</CODE></A>, 
<A HREF="../../../org/hsqldb/jdbc/jdbcResultSet.html" title="class in org.hsqldb.jdbc"><CODE>jdbcResultSet</CODE></A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.sql.Statement"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from interface java.sql.Statement</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>CLOSE_ALL_RESULTS, CLOSE_CURRENT_RESULT, EXECUTE_FAILED, KEEP_CURRENT_RESULT, NO_GENERATED_KEYS, RETURN_GENERATED_KEYS, SUCCESS_NO_INFO</CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#addBatch()">addBatch</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Adds a set of parameters to this <code>PreparedStatement</code>
 object's batch of commands.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#addBatch(java.lang.String)">addBatch</A></B>(java.lang.String&nbsp;sql)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method should always throw if called for a PreparedStatement or
 CallableStatment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#clearParameters()">clearParameters</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Clears the current parameter values immediately.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#close()">close</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Does the specialized work required to free this object's resources and
 that of it's parent class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#execute()">execute</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Executes the SQL statement in this <code>PreparedStatement</code>
 object, which may be any kind of SQL statement.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#execute(java.lang.String)">execute</A></B>(java.lang.String&nbsp;sql)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method should always throw if called for a PreparedStatement or
 CallableStatment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#executeBatch()">executeBatch</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Submits a batch of commands to the database for execution and
 if all commands execute successfully, returns an array of update counts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.ResultSet</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#executeQuery()">executeQuery</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Executes the SQL query in this <code>PreparedStatement</code> object
 and returns the <code>ResultSet</code> object generated by the query.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.ResultSet</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#executeQuery(java.lang.String)">executeQuery</A></B>(java.lang.String&nbsp;sql)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method should always throw if called for a PreparedStatement or
 CallableStatment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#executeUpdate()">executeUpdate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Executes the SQL statement in this <code>PreparedStatement</code>
 object, which must be an SQL <code>INSERT</code>,
 <code>UPDATE</code> or <code>DELETE</code> statement; or an SQL
 statement that returns nothing, such as a DDL statement.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#executeUpdate(java.lang.String)">executeUpdate</A></B>(java.lang.String&nbsp;sql)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method should always throw if called for a PreparedStatement or
 CallableStatment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.ResultSetMetaData</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#getMetaData()">getMetaData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Retrieves a <code>ResultSetMetaData</code> object that contains
 information about the columns of the <code>ResultSet</code> object
 that will be returned when this <code>PreparedStatement</code> object
 is executed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.sql.ParameterMetaData</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#getParameterMetaData()">getParameterMetaData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Retrieves the number, types and properties of this
 <code>PreparedStatement</code> object's parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setArray(int, java.sql.Array)">setArray</A></B>(int&nbsp;i,
         java.sql.Array&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given <code>Array</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setAsciiStream(int, java.io.InputStream, int)">setAsciiStream</A></B>(int&nbsp;parameterIndex,
               java.io.InputStream&nbsp;x,
               int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setBigDecimal(int, java.math.BigDecimal)">setBigDecimal</A></B>(int&nbsp;parameterIndex,
              java.math.BigDecimal&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given
 <code>java.math.BigDecimal</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setBinaryStream(int, java.io.InputStream, int)">setBinaryStream</A></B>(int&nbsp;parameterIndex,
                java.io.InputStream&nbsp;x,
                int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setBlob(int, java.sql.Blob)">setBlob</A></B>(int&nbsp;i,
        java.sql.Blob&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given <code>Blob</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setBoolean(int, boolean)">setBoolean</A></B>(int&nbsp;parameterIndex,
           boolean&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given Java <code>boolean</code>
 value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setByte(int, byte)">setByte</A></B>(int&nbsp;parameterIndex,
        byte&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given Java <code>byte</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setBytes(int, byte[])">setBytes</A></B>(int&nbsp;paramIndex,
         byte[]&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given Java array of bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setCharacterStream(int, java.io.Reader, int)">setCharacterStream</A></B>(int&nbsp;parameterIndex,
                   java.io.Reader&nbsp;reader,
                   int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given <code>Reader</code>
 object, which is the given number of characters long.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setClob(int, java.sql.Clob)">setClob</A></B>(int&nbsp;i,
        java.sql.Clob&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given <code>Clob</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setDate(int, java.sql.Date)">setDate</A></B>(int&nbsp;parameterIndex,
        java.sql.Date&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given
 <code>java.sql.Date</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setDate(int, java.sql.Date, java.util.Calendar)">setDate</A></B>(int&nbsp;parameterIndex,
        java.sql.Date&nbsp;x,
        java.util.Calendar&nbsp;cal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given <code>java.sql.Date</code>
 value, using the given <code>Calendar</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setDouble(int, double)">setDouble</A></B>(int&nbsp;parameterIndex,
          double&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given Java <code>double</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setEscapeProcessing(boolean)">setEscapeProcessing</A></B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets escape processing on or off.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setFloat(int, float)">setFloat</A></B>(int&nbsp;parameterIndex,
         float&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given Java <code>float</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setInt(int, int)">setInt</A></B>(int&nbsp;parameterIndex,
       int&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given Java <code>int</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setLong(int, long)">setLong</A></B>(int&nbsp;parameterIndex,
        long&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given Java <code>long</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setNull(int, int)">setNull</A></B>(int&nbsp;paramIndex,
        int&nbsp;sqlType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to SQL <code>NULL</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setNull(int, int, java.lang.String)">setNull</A></B>(int&nbsp;paramIndex,
        int&nbsp;sqlType,
        java.lang.String&nbsp;typeName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to SQL <code>NULL</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setObject(int, java.lang.Object)">setObject</A></B>(int&nbsp;parameterIndex,
          java.lang.Object&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the value of the designated parameter using the given object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setObject(int, java.lang.Object, int)">setObject</A></B>(int&nbsp;parameterIndex,
          java.lang.Object&nbsp;x,
          int&nbsp;targetSqlType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the value of the designated parameter with the given object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setObject(int, java.lang.Object, int, int)">setObject</A></B>(int&nbsp;parameterIndex,
          java.lang.Object&nbsp;x,
          int&nbsp;targetSqlType,
          int&nbsp;scale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the value of the designated parameter with the given object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setRef(int, java.sql.Ref)">setRef</A></B>(int&nbsp;i,
       java.sql.Ref&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given
 <code>REF(&lt;structured-type&gt;)</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setShort(int, short)">setShort</A></B>(int&nbsp;parameterIndex,
         short&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given Java <code>short</code>
 value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setString(int, java.lang.String)">setString</A></B>(int&nbsp;parameterIndex,
          java.lang.String&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given Java <code>String</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setTime(int, java.sql.Time)">setTime</A></B>(int&nbsp;parameterIndex,
        java.sql.Time&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given <code>java.sql.Time</code>
 value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setTime(int, java.sql.Time, java.util.Calendar)">setTime</A></B>(int&nbsp;parameterIndex,
        java.sql.Time&nbsp;x,
        java.util.Calendar&nbsp;cal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given <code>java.sql.Time</code>
 value, using the given <code>Calendar</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setTimestamp(int, java.sql.Timestamp)">setTimestamp</A></B>(int&nbsp;parameterIndex,
             java.sql.Timestamp&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given
 <code>java.sql.Timestamp</code> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setTimestamp(int, java.sql.Timestamp, java.util.Calendar)">setTimestamp</A></B>(int&nbsp;parameterIndex,
             java.sql.Timestamp&nbsp;x,
             java.util.Calendar&nbsp;cal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given <code>java.sql.Timestamp</code>
 value, using the given <code>Calendar</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setUnicodeStream(int, java.io.InputStream, int)">setUnicodeStream</A></B>(int&nbsp;parameterIndex,
                 java.io.InputStream&nbsp;x,
                 int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Sun does not include a reason, but presumably
      this is because setCharacterStream is now prefered</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setURL(int, java.net.URL)">setURL</A></B>(int&nbsp;parameterIndex,
       java.net.URL&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Sets the designated parameter to the given <code>java.net.URL</code>
 value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves a String representation of this object.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_org.hsqldb.jdbc.jdbcStatement"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class org.hsqldb.jdbc.<A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html" title="class in org.hsqldb.jdbc">jdbcStatement</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#cancel()">cancel</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#clearBatch()">clearBatch</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#clearWarnings()">clearWarnings</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#execute(java.lang.String, int)">execute</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#execute(java.lang.String, int[])">execute</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#execute(java.lang.String, java.lang.String[])">execute</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#executeUpdate(java.lang.String, int)">executeUpdate</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#executeUpdate(java.lang.String, int[])">executeUpdate</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#executeUpdate(java.lang.String, java.lang.String[])">executeUpdate</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getConnection()">getConnection</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getFetchDirection()">getFetchDirection</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getFetchSize()">getFetchSize</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getGeneratedKeys()">getGeneratedKeys</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getMaxFieldSize()">getMaxFieldSize</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getMaxRows()">getMaxRows</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getMoreResults()">getMoreResults</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getMoreResults(int)">getMoreResults</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getQueryTimeout()">getQueryTimeout</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getResultSet()">getResultSet</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getResultSetConcurrency()">getResultSetConcurrency</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getResultSetHoldability()">getResultSetHoldability</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getResultSetType()">getResultSetType</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getUpdateCount()">getUpdateCount</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getWarnings()">getWarnings</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#setCursorName(java.lang.String)">setCursorName</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#setFetchDirection(int)">setFetchDirection</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#setFetchSize(int)">setFetchSize</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#setMaxFieldSize(int)">setMaxFieldSize</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#setMaxRows(int)">setMaxRows</A>, <A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#setQueryTimeout(int)">setQueryTimeout</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.sql.Statement"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from interface java.sql.Statement</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>cancel, clearBatch, clearWarnings, execute, execute, execute, executeUpdate, executeUpdate, executeUpdate, getConnection, getFetchDirection, getFetchSize, getGeneratedKeys, getMaxFieldSize, getMaxRows, getMoreResults, getMoreResults, getQueryTimeout, getResultSet, getResultSetConcurrency, getResultSetHoldability, getResultSetType, getUpdateCount, getWarnings, setCursorName, setFetchDirection, setFetchSize, setMaxFieldSize, setMaxRows, setQueryTimeout</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="setEscapeProcessing(boolean)"><!-- --></A><H3>
setEscapeProcessing</H3>
<PRE>
public void <B>setEscapeProcessing</B>(boolean&nbsp;enable)
                         throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets escape processing on or off. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.0, the implementation follows the standard
 behaviour by overriding the same method in jdbcStatement
 class. <p>

 In other words, calling this method has no effect.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setEscapeProcessing</CODE> in interface <CODE>java.sql.Statement</CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#setEscapeProcessing(boolean)">setEscapeProcessing</A></CODE> in class <CODE><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html" title="class in org.hsqldb.jdbc">jdbcStatement</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enable</CODE> - <code>true</code> to enable escape processing;
     <code>false</code> to disable it
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="execute()"><!-- --></A><H3>
execute</H3>
<PRE>
public boolean <B>execute</B>()
                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Executes the SQL statement in this <code>PreparedStatement</code>
 object, which may be any kind of SQL statement.
 Some prepared statements return multiple results; the
 <code>execute</code> method handles these complex statements as well
 as the simpler form of statements handled by the methods
 <code>executeQuery</code>and <code>executeUpdate</code>. <p>

 The <code>execute</code> method returns a <code>boolean</code> to
 indicate the form of the first result.  You must call either the method
 <code>getResultSet</code> or <code>getUpdateCount</code>
 to retrieve the result; you must call <code>getMoreResults</code> to
 move to any subsequent result(s). <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Including 1.7.2, prepared statements do not generate
 multiple fetchable results. <p>

 Following 1.7.2, it will be possible that statements
 generate multiple fetchable results under certain conditions.
 </div>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>execute</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if the first result is a <code>ResultSet</code>
    object; <code>false</code> if the first result is an update
    count or there is no result
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or an argument
       is supplied to this method<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#execute(java.lang.String)"><CODE>jdbcStatement.execute(java.lang.String)</CODE></A>, 
<A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getResultSet()"><CODE>jdbcStatement.getResultSet()</CODE></A>, 
<A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getUpdateCount()"><CODE>jdbcStatement.getUpdateCount()</CODE></A>, 
<A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getMoreResults()"><CODE>jdbcStatement.getMoreResults()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="executeQuery()"><!-- --></A><H3>
executeQuery</H3>
<PRE>
public java.sql.ResultSet <B>executeQuery</B>()
                                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Executes the SQL query in this <code>PreparedStatement</code> object
 and returns the <code>ResultSet</code> object generated by the query.<p>
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>executeQuery</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a <code>ResultSet</code> object that contains the data produced
    by the query; never <code>null</code>
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or the SQL
       statement does not return a <code>ResultSet</code> object</DL>
</DD>
</DL>
<HR>

<A NAME="executeUpdate()"><!-- --></A><H3>
executeUpdate</H3>
<PRE>
public int <B>executeUpdate</B>()
                  throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Executes the SQL statement in this <code>PreparedStatement</code>
 object, which must be an SQL <code>INSERT</code>,
 <code>UPDATE</code> or <code>DELETE</code> statement; or an SQL
 statement that returns nothing, such as a DDL statement.<p>
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>executeUpdate</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>either (1) the row count for <code>INSERT</code>,
     <code>UPDATE</code>, or <code>DELETE</code>
     statements or (2) 0 for SQL statements that
     return nothing
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or the SQL
        statement returns a <code>ResultSet</code> object</DL>
</DD>
</DL>
<HR>

<A NAME="executeBatch()"><!-- --></A><H3>
executeBatch</H3>
<PRE>
public int[] <B>executeBatch</B>()
                   throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Submits a batch of commands to the database for execution and
 if all commands execute successfully, returns an array of update counts.
 The <code>int</code> elements of the array that is returned are ordered
 to correspond to the commands in the batch, which are ordered
 according to the order in which they were added to the batch.
 The elements in the array returned by the method <code>executeBatch</code>
 may be one of the following:
 <OL>
 <LI>A number greater than or equal to zero -- indicates that the
 command was processed successfully and is an update count giving the
 number of rows in the database that were affected by the command's
 execution
 <LI>A value of <code>SUCCESS_NO_INFO</code> -- indicates that the command was
 processed successfully but that the number of rows affected is
 unknown
 <P>
 If one of the commands in a batch update fails to execute properly,
 this method throws a <code>BatchUpdateException</code>, and a JDBC
 driver may or may not continue to process the remaining commands in
 the batch.  However, the driver's behavior must be consistent with a
 particular DBMS, either always continuing to process commands or never
 continuing to process commands.  If the driver continues processing
 after a failure, the array returned by the method
 <code>BatchUpdateException.getUpdateCounts</code>
 will contain as many elements as there are commands in the batch, and
 at least one of the elements will be the following:
 <P>
 <LI>A value of <code>EXECUTE_FAILED</code> -- indicates that the command failed
 to execute successfully and occurs only if a driver continues to
 process commands after a command fails
 </OL>
 <P>
 A driver is not required to implement this method.
 The possible implementations and return values have been modified in
 the Java 2 SDK, Standard Edition, version 1.3 to
 accommodate the option of continuing to proccess commands in a batch
 update after a <code>BatchUpdateException</code> obejct has been thrown. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Starting with HSQLDB 1.7.2, this feature is supported. <p>

 HSQLDB stops execution of commands in a batch when one of the commands
 results in an exception. The size of the returned array equals the
 number of commands that were executed successfully.<p>

 When the product is built under the JAVA1 target, an exception
 is never thrown and it is the responsibility of the client software to
 check the size of the  returned update count array to determine if any
 batch items failed.  To build and run under the JAVA2 target, JDK/JRE
 1.3 or higher must be used.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>executeBatch</CODE> in interface <CODE>java.sql.Statement</CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#executeBatch()">executeBatch</A></CODE> in class <CODE><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html" title="class in org.hsqldb.jdbc">jdbcStatement</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>an array of update counts containing one element for each
 command in the batch.  The elements of the array are ordered according
 to the order in which commands were added to the batch.
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or the
 driver does not support batch statements. Throws
 <CODE>BatchUpdateException</CODE>
 (a subclass of <code>java.sql.SQLException</code>) if one of the commands
 sent  to the database fails to execute properly or attempts to return a
 result set.<DT><B>Since:</B></DT>
  <DD>JDK 1.3 (JDK 1.1.x developers: read the new overview
   for jdbcStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNull(int, int)"><!-- --></A><H3>
setNull</H3>
<PRE>
public void <B>setNull</B>(int&nbsp;paramIndex,
                    int&nbsp;sqlType)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to SQL <code>NULL</code>. <p>

 <B>Note:</B> You must specify the parameter's SQL type.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 HSQLDB ignores the sqlType argument.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setNull</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>paramIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>sqlType</CODE> - the SQL type code defined in <code>java.sql.Types</code>
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setBoolean(int, boolean)"><!-- --></A><H3>
setBoolean</H3>
<PRE>
public void <B>setBoolean</B>(int&nbsp;parameterIndex,
                       boolean&nbsp;x)
                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>boolean</code>
 value.  The driver converts this to an SQL <code>BIT</code> value
 when it sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.2, HSQLDB uses the BOOLEAN type instead of BIT, as
 per SQL 200n (SQL 3).
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setBoolean</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setByte(int, byte)"><!-- --></A><H3>
setByte</H3>
<PRE>
public void <B>setByte</B>(int&nbsp;parameterIndex,
                    byte&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>byte</code> value.
 The driver converts this to an SQL <code>TINYINT</code> value when
 it sends it to the database.<p>
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setByte</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setShort(int, short)"><!-- --></A><H3>
setShort</H3>
<PRE>
public void <B>setShort</B>(int&nbsp;parameterIndex,
                     short&nbsp;x)
              throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>short</code>
 value. The driver converts this to an SQL <code>SMALLINT</code>
 value when it sends it to the database.<p>
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setShort</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setInt(int, int)"><!-- --></A><H3>
setInt</H3>
<PRE>
public void <B>setInt</B>(int&nbsp;parameterIndex,
                   int&nbsp;x)
            throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>int</code> value.
 The driver converts this to an SQL <code>INTEGER</code> value when
 it sends it to the database.<p>
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setInt</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setLong(int, long)"><!-- --></A><H3>
setLong</H3>
<PRE>
public void <B>setLong</B>(int&nbsp;parameterIndex,
                    long&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>long</code> value.
 The driver converts this to an SQL <code>BIGINT</code> value when
 it sends it to the database.<p>
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setLong</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setFloat(int, float)"><!-- --></A><H3>
setFloat</H3>
<PRE>
public void <B>setFloat</B>(int&nbsp;parameterIndex,
                     float&nbsp;x)
              throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>float</code> value.
 The driver converts this to an SQL <code>FLOAT</code> value when
 it sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.1, HSQLDB handles Java positive/negative Infinity
 and NaN <code>float</code> values consistent with the Java Language
 Specification; these <em>special</em> values are now correctly stored
 to and retrieved from the database.
 </div>
 <!-- start release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setFloat</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setDouble(int, double)"><!-- --></A><H3>
setDouble</H3>
<PRE>
public void <B>setDouble</B>(int&nbsp;parameterIndex,
                      double&nbsp;x)
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>double</code> value.
 The driver converts this to an SQL <code>DOUBLE</code> value when it
 sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.1, HSQLDB handles Java positive/negative Infinity
 and NaN <code>double</code> values consistent with the Java Language
 Specification; these <em>special</em> values are now correctly stored
 to and retrieved from the database.
 </div>
 <!-- start release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setDouble</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setBigDecimal(int, java.math.BigDecimal)"><!-- --></A><H3>
setBigDecimal</H3>
<PRE>
public void <B>setBigDecimal</B>(int&nbsp;parameterIndex,
                          java.math.BigDecimal&nbsp;x)
                   throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given
 <code>java.math.BigDecimal</code> value.
 The driver converts this to an SQL <code>NUMERIC</code> value when
 it sends it to the database.<p>
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setBigDecimal</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setString(int, java.lang.String)"><!-- --></A><H3>
setString</H3>
<PRE>
public void <B>setString</B>(int&nbsp;parameterIndex,
                      java.lang.String&nbsp;x)
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>String</code> value.
 The driver converts this
 to an SQL <code>VARCHAR</code> or <code>LONGVARCHAR</code> value
 (depending on the argument's
 size relative to the driver's limits on <code>VARCHAR</code> values)
 when it sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Including 1.7.2, HSQLDB stores all XXXCHAR values as java.lang.String
 objects; there is no appreciable difference between
 CHAR, VARCHAR and LONGVARCHAR.
 </div>
 <!-- start release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setString</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setBytes(int, byte[])"><!-- --></A><H3>
setBytes</H3>
<PRE>
public void <B>setBytes</B>(int&nbsp;paramIndex,
                     byte[]&nbsp;x)
              throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given Java array of bytes.
 The driver converts this to an SQL <code>VARBINARY</code> or
 <code>LONGVARBINARY</code> (depending on the argument's size relative
 to the driver's limits on <code>VARBINARY</code> values) when it
 sends it to the database.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Including 1.7.2, HSQLDB stores all XXXBINARY values the same way; there
 is no appreciable difference between BINARY, VARBINARY and
 LONGVARBINARY.
 </div>
 <!-- start release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setBytes</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>paramIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setDate(int, java.sql.Date)"><!-- --></A><H3>
setDate</H3>
<PRE>
public void <B>setDate</B>(int&nbsp;parameterIndex,
                    java.sql.Date&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given
 <code>java.sql.Date</code> value.  The driver converts this
 to an SQL <code>DATE</code> value when it sends it to the database.<p>
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setDate</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setTime(int, java.sql.Time)"><!-- --></A><H3>
setTime</H3>
<PRE>
public void <B>setTime</B>(int&nbsp;parameterIndex,
                    java.sql.Time&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Time</code>
 value. The driver converts this to an SQL <code>TIME</code> value when it
 sends it to the database.<p>
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setTime</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setTimestamp(int, java.sql.Timestamp)"><!-- --></A><H3>
setTimestamp</H3>
<PRE>
public void <B>setTimestamp</B>(int&nbsp;parameterIndex,
                         java.sql.Timestamp&nbsp;x)
                  throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given
 <code>java.sql.Timestamp</code> value.  The driver converts this to
 an SQL <code>TIMESTAMP</code> value when it sends it to the
 database.<p>
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setTimestamp</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setAsciiStream(int, java.io.InputStream, int)"><!-- --></A><H3>
setAsciiStream</H3>
<PRE>
public void <B>setAsciiStream</B>(int&nbsp;parameterIndex,
                           java.io.InputStream&nbsp;x,
                           int&nbsp;length)
                    throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.
 When a very large ASCII value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code>. Data will be read from the stream
 as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from ASCII to the database char format. <p>

 <b>Note:</b> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.<p>
 <!-- end generic documentation -->
 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 This method uses the default platform character encoding to convert bytes
 from the stream into the characters of a String. In the future this is
 likely to change to always treat the stream as ASCII.<p>

 Before HSQLDB 1.7.0, <code>setAsciiStream</code> and
 <code>setUnicodeStream</code> were identical.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setAsciiStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the Java input stream that contains the ASCII parameter value<DD><CODE>length</CODE> - the number of bytes in the stream
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setUnicodeStream(int, java.io.InputStream, int)"><!-- --></A><H3>
setUnicodeStream</H3>
<PRE>
public void <B>setUnicodeStream</B>(int&nbsp;parameterIndex,
                             java.io.InputStream&nbsp;x,
                             int&nbsp;length)
                      throws java.sql.SQLException</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Sun does not include a reason, but presumably
      this is because setCharacterStream is now prefered</I>
<P>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given input stream, which
 will have the specified number of bytes. A Unicode character has
 two bytes, with the first byte being the high byte, and the second
 being the low byte.

 When a very large Unicode value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code> object. The data will be read from the
 stream as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from Unicode to the database char format.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.0, this method complies with behavior as defined by the
 JDBC3 specification.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setUnicodeStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - a <code>java.io.InputStream</code> object that contains the
      Unicode parameter value as two-byte Unicode characters<DD><CODE>length</CODE> - the number of bytes in the stream
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setBinaryStream(int, java.io.InputStream, int)"><!-- --></A><H3>
setBinaryStream</H3>
<PRE>
public void <B>setBinaryStream</B>(int&nbsp;parameterIndex,
                            java.io.InputStream&nbsp;x,
                            int&nbsp;length)
                     throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.
 When a very large binary value is input to a <code>LONGVARBINARY</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code> object. The data will be read from the
 stream as needed until end-of-file is reached.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.2, this method works according to the standard.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setBinaryStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the java input stream which contains the binary parameter value<DD><CODE>length</CODE> - the number of bytes in the stream
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="clearParameters()"><!-- --></A><H3>
clearParameters</H3>
<PRE>
public void <B>clearParameters</B>()
                     throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Clears the current parameter values immediately. <p>

 In general, parameter values remain in force for repeated use of a
 statement. Setting a parameter value automatically clears its
 previous value.  However, in some cases it is useful to immediately
 release the resources used by the current parameter values; this can
 be done by calling the method <code>clearParameters</code>.<p>
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>clearParameters</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="setObject(int, java.lang.Object, int, int)"><!-- --></A><H3>
setObject</H3>
<PRE>
public void <B>setObject</B>(int&nbsp;parameterIndex,
                      java.lang.Object&nbsp;x,
                      int&nbsp;targetSqlType,
                      int&nbsp;scale)
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the value of the designated parameter with the given object. <p>

 The second argument must be an object type; for integral values, the
 <code>java.lang</code> equivalent objects should be used. <p>

 The given Java object will be converted to the given targetSqlType
 before being sent to the database.

 If the object has a custom mapping (is of a class implementing the
 interface <code>SQLData</code>),
 the JDBC driver should call the method <code>SQLData.writeSQL</code> to
 write it to the SQL data stream.
 If, on the other hand, the object is of a class implementing
 <code>Ref</code>, <code>Blob</code>, <code>Clob</code>,
 <code>Struct</code>, or <code>Array</code>, the driver should pass it
 to the database as a value of the corresponding SQL type. <p>

 Note that this method may be used to pass database-specific
 abstract data types.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Inculding 1.7.1,this method was identical to
 <A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setObject(int, java.lang.Object, int)"><CODE>setObject(int, Object, int)</CODE></A>.
 That is, this method simply called setObject(int, Object, int),
 ignoring the scale specification. <p>

 Since 1.7.2, this method supports the conversions listed in the
 conversion table B-5 of the JDBC 3 specification. The scale argument
 is not used.
 </div>
 <!-- start release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setObject</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the object containing the input parameter value<DD><CODE>targetSqlType</CODE> - the SQL type (as defined in java.sql.Types) to be
 sent to the database. The scale argument may further qualify this type.<DD><CODE>scale</CODE> - for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types,
     this is the number of digits after the decimal point.  For all
     other types, this value will be ignored. <p>

     Up to and including HSQLDB 1.7.0, this parameter is ignored.
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also:</B><DD><CODE>Types</CODE>, 
<A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setObject(int, java.lang.Object, int)"><CODE>setObject(int,Object,int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setObject(int, java.lang.Object, int)"><!-- --></A><H3>
setObject</H3>
<PRE>
public void <B>setObject</B>(int&nbsp;parameterIndex,
                      java.lang.Object&nbsp;x,
                      int&nbsp;targetSqlType)
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the value of the designated parameter with the given object.
 This method is like the method <code>setObject</code>
 above, except that it assumes a scale of zero. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.2, this method supports conversions listed in the
 conversion table B-5 of the JDBC 3 specification.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setObject</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the object containing the input parameter value<DD><CODE>targetSqlType</CODE> - the SQL type (as defined in java.sql.Types) to be
                sent to the database
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/jdbcPreparedStatement.html#setObject(int, java.lang.Object)"><CODE>setObject(int,Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setObject(int, java.lang.Object)"><!-- --></A><H3>
setObject</H3>
<PRE>
public void <B>setObject</B>(int&nbsp;parameterIndex,
                      java.lang.Object&nbsp;x)
               throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the value of the designated parameter using the given object. <p>

 The second parameter must be of type <code>Object</code>; therefore,
 the <code>java.lang</code> equivalent objects should be used for
 built-in types. <p>

 The JDBC specification specifies a standard mapping from
 Java <code>Object</code> types to SQL types.  The given argument
 will be converted to the corresponding SQL type before being
 sent to the database. <p>

 Note that this method may be used to pass datatabase-
 specific abstract data types, by using a driver-specific Java
 type.  If the object is of a class implementing the interface
 <code>SQLData</code>, the JDBC driver should call the method
 <code>SQLData.writeSQL</code> to write it to the SQL data stream.
 If, on the other hand, the object is of a class implementing
 <code>Ref</code>, <code>Blob</code>, <code>Clob</code>,
 <code>Struct</code>, or <code>Array</code>, the driver should pass
 it to the database as a value of the corresponding SQL type. <p>

 This method throws an exception if there is an ambiguity, for
 example, if the object is of a class implementing more than one
 of the interfaces named above.<p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3><p>

 Since 1.7.2, this method supports conversions listed in the conversion
 table B-5 of the JDBC 3 specification.<p>

 </div>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setObject</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the object containing the input parameter value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs or the type
      of the given object is ambiguous</DL>
</DD>
</DL>
<HR>

<A NAME="addBatch()"><!-- --></A><H3>
addBatch</H3>
<PRE>
public void <B>addBatch</B>()
              throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Adds a set of parameters to this <code>PreparedStatement</code>
 object's batch of commands. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.2, this feature is supported.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>addBatch</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
 jdbcPreparedStatement)</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#addBatch(java.lang.String)"><CODE>jdbcStatement.addBatch(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setCharacterStream(int, java.io.Reader, int)"><!-- --></A><H3>
setCharacterStream</H3>
<PRE>
public void <B>setCharacterStream</B>(int&nbsp;parameterIndex,
                               java.io.Reader&nbsp;reader,
                               int&nbsp;length)
                        throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>Reader</code>
 object, which is the given number of characters long.
 When a very large UNICODE value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.Reader</code> object. The data will be read from the
 stream as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from UNICODE to the database char format.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 HSQLDB stores CHARACTER and related SQL types as Unicode so
 this method does not perform any conversion.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setCharacterStream</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>reader</CODE> - the <code>java.io.Reader</code> object that contains the
 Unicode data<DD><CODE>length</CODE> - the number of characters in the stream
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
 jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setRef(int, java.sql.Ref)"><!-- --></A><H3>
setRef</H3>
<PRE>
public void <B>setRef</B>(int&nbsp;i,
                   java.sql.Ref&nbsp;x)
            throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given
 <code>REF(&lt;structured-type&gt;)</code> value.
 The driver converts this to an SQL <code>REF</code> value when it
 sends it to the database. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 HSQLDB 1.7.2 does not support the SQL REF type. Calling this method
 throws an exception.

 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setRef</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - an SQL <code>REF</code> value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
 jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setBlob(int, java.sql.Blob)"><!-- --></A><H3>
setBlob</H3>
<PRE>
public void <B>setBlob</B>(int&nbsp;i,
                    java.sql.Blob&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>Blob</code> object.
 The driver converts this to an SQL <code>BLOB</code> value when it
 sends it to the database. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Previous to 1.7.2, this feature was not supported. <p>

 Since 1.7.2, setBlob is supported.  With 1.7.2, setting Blob objects is
 limited to those of length less than or equal to Integer.MAX_VALUE.
 In 1.7.2, setBlob(i,x) is roughly equivalent (null and length handling
 not shown) to:

 <pre class="JavaCodeExample">
 <b>setBinaryStream</b>(i, x.<b>getBinaryStream</b>(), (<span class="JavaKeyWord">int</span>) x.<b>length</b>());
 </pre></div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setBlob</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - a <code>Blob</code> object that maps an SQL <code>BLOB</code>
     value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
 jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setClob(int, java.sql.Clob)"><!-- --></A><H3>
setClob</H3>
<PRE>
public void <B>setClob</B>(int&nbsp;i,
                    java.sql.Clob&nbsp;x)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>Clob</code> object.
 The driver converts this to an SQL <code>CLOB</code> value when it
 sends it to the database. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Previous to 1.7.2, this feature was not supported. <p>

 Since 1.7.2, setClob is supported.  With 1.7.2, setting Blob objects is
 limited to those of length less than or equal to Integer.MAX_VALUE.
 In 1.7.2, setClob(i,x) is rougly equivalent (null and length handling
 not shown) to: <p>

 <pre class="JavaCodeExample">
 <b>setCharacterStream</b>(i, x.<b>getCharacterStream</b>(), (<span class="JavaKeyWord">int</span>) x.<b>length</b>());
 </pre></div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setClob</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - a <code>Clob</code> object that maps an SQL <code>CLOB</code>
      value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
  jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setArray(int, java.sql.Array)"><!-- --></A><H3>
setArray</H3>
<PRE>
public void <B>setArray</B>(int&nbsp;i,
                     java.sql.Array&nbsp;x)
              throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>Array</code> object.
 The driver converts this to an SQL <code>ARRAY</code> value when it
 sends it to the database. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 HSQLDB 1.7.2 does not support the SQL ARRAY type. Calling this method
 throws an exception.

 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setArray</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - an <code>Array</code> object that maps an SQL <code>ARRAY</code>
       value
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
   jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMetaData()"><!-- --></A><H3>
getMetaData</H3>
<PRE>
public java.sql.ResultSetMetaData <B>getMetaData</B>()
                                       throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves a <code>ResultSetMetaData</code> object that contains
 information about the columns of the <code>ResultSet</code> object
 that will be returned when this <code>PreparedStatement</code> object
 is executed.
 <P>
 Because a <code>PreparedStatement</code> object is precompiled, it is
 possible to know about the <code>ResultSet</code> object that it will
 return without having to execute it.  Consequently, it is possible
 to invoke the method <code>getMetaData</code> on a
 <code>PreparedStatement</code> object rather than waiting to execute
 it and then invoking the <code>ResultSet.getMetaData</code> method
 on the <code>ResultSet</code> object that is returned.
 <P>
 <B>NOTE:</B> Using this method may be expensive for some drivers due
 to the lack of underlying DBMS support. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.2, this feature is supported.  If the statement
 generates an update count, then null is returned.

 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getMetaData</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the description of a <code>ResultSet</code> object's columns or
    <code>null</code> if the driver cannot return a
    <code>ResultSetMetaData</code> object
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
   jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDate(int, java.sql.Date, java.util.Calendar)"><!-- --></A><H3>
setDate</H3>
<PRE>
public void <B>setDate</B>(int&nbsp;parameterIndex,
                    java.sql.Date&nbsp;x,
                    java.util.Calendar&nbsp;cal)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Date</code>
 value, using the given <code>Calendar</code> object.  The driver uses
 the <code>Calendar</code> object to construct an SQL <code>DATE</code>
 value,which the driver then sends to the database.  With a
 a <code>Calendar</code> object, the driver can calculate the date
 taking into account a custom timezone.  If no
 <code>Calendar</code> object is specified, the driver uses the default
 timezone, which is that of the virtual machine running the
 application. <p>
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setDate</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DD><CODE>cal</CODE> - the <code>Calendar</code> object the driver will use
       to construct the date
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
   jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTime(int, java.sql.Time, java.util.Calendar)"><!-- --></A><H3>
setTime</H3>
<PRE>
public void <B>setTime</B>(int&nbsp;parameterIndex,
                    java.sql.Time&nbsp;x,
                    java.util.Calendar&nbsp;cal)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Time</code>
 value, using the given <code>Calendar</code> object.  The driver uses
 the <code>Calendar</code> object to construct an SQL <code>TIME</code>
 value, which the driver then sends to the database.  With a
 a <code>Calendar</code> object, the driver can calculate the time
 taking into account a custom timezone.  If no
 <code>Calendar</code> object is specified, the driver uses the default
 timezone, which is that of the virtual machine running the
 application. <p>
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setTime</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DD><CODE>cal</CODE> - the <code>Calendar</code> object the driver will use
       to construct the time
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
   jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTimestamp(int, java.sql.Timestamp, java.util.Calendar)"><!-- --></A><H3>
setTimestamp</H3>
<PRE>
public void <B>setTimestamp</B>(int&nbsp;parameterIndex,
                         java.sql.Timestamp&nbsp;x,
                         java.util.Calendar&nbsp;cal)
                  throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Timestamp</code>
 value, using the given <code>Calendar</code> object.  The driver uses
 the <code>Calendar</code> object to construct an SQL <code>TIMESTAMP</code>
 value, which the driver then sends to the database.  With a
 <code>Calendar</code> object, the driver can calculate the timestamp
 taking into account a custom timezone.  If no
 <code>Calendar</code> object is specified, the driver uses the default
 timezone, which is that of the virtual machine running the application. <p>
 <!-- end generic documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setTimestamp</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the parameter value<DD><CODE>cal</CODE> - the <code>Calendar</code> object the driver will use
       to construct the timestamp
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
   jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNull(int, int, java.lang.String)"><!-- --></A><H3>
setNull</H3>
<PRE>
public void <B>setNull</B>(int&nbsp;paramIndex,
                    int&nbsp;sqlType,
                    java.lang.String&nbsp;typeName)
             throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to SQL <code>NULL</code>.
 This version of the method <code>setNull</code> should
 be used for user-defined types and REF type parameters.  Examples
 of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT, and
 named array types.

 <P><B>Note:</B> To be portable, applications must give the
 SQL type code and the fully-qualified SQL type name when specifying
 a NULL user-defined or REF parameter.  In the case of a user-defined
 type the name is the type name of the parameter itself.  For a REF
 parameter, the name is the type name of the referenced type.  If
 a JDBC driver does not need the type code or type name information,
 it may ignore it.

 Although it is intended for user-defined and Ref parameters,
 this method may be used to set a null parameter of any JDBC type.
 If the parameter does not have a user-defined or REF type, the given
 typeName is ignored. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 HSQLDB ignores the sqlType and typeName arguments.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setNull</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>paramIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>sqlType</CODE> - a value from <code>java.sql.Types</code><DD><CODE>typeName</CODE> - the fully-qualified name of an SQL user-defined type;
 ignored if the parameter is not a user-defined type or REF
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since:</B></DT>
  <DD>JDK 1.2 (JDK 1.1.x developers: read the new overview for
   jdbcPreparedStatement)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setURL(int, java.net.URL)"><!-- --></A><H3>
setURL</H3>
<PRE>
public void <B>setURL</B>(int&nbsp;parameterIndex,
                   java.net.URL&nbsp;x)
            throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.net.URL</code>
 value. The driver converts this to an SQL <code>DATALINK</code> value
 when it sends it to the database. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 HSQLDB 1.7.2 does not support the DATALINK SQL type for which this
 method is intended. Calling this method throws an exception.

 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>setURL</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterIndex</CODE> - the first parameter is 1, the second is 2, ...<DD><CODE>x</CODE> - the <code>java.net.URL</code> object to be set
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since:</B></DT>
  <DD>JDK 1.4, HSQL 1.7.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getParameterMetaData()"><!-- --></A><H3>
getParameterMetaData</H3>
<PRE>
public java.sql.ParameterMetaData <B>getParameterMetaData</B>()
                                                throws java.sql.SQLException</PRE>
<DL>
<DD><!-- start generic documentation -->
 Retrieves the number, types and properties of this
 <code>PreparedStatement</code> object's parameters. <p>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h3>HSQLDB-Specific Information:</h3> <p>

 Since 1.7.2, this feature is supported.
 </div>
 <!-- end release-specific documentation -->
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getParameterMetaData</CODE> in interface <CODE>java.sql.PreparedStatement</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a <code>ParameterMetaData</code> object that contains information
    about the number, types and properties of this
    <code>PreparedStatement</code> object's parameters
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs<DT><B>Since:</B></DT>
  <DD>JDK 1.4, HSQL 1.7.0</DD>
<DT><B>See Also:</B><DD><CODE>ParameterMetaData</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="addBatch(java.lang.String)"><!-- --></A><H3>
addBatch</H3>
<PRE>
public void <B>addBatch</B>(java.lang.String&nbsp;sql)
              throws java.sql.SQLException</PRE>
<DL>
<DD>This method should always throw if called for a PreparedStatement or
 CallableStatment.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>addBatch</CODE> in interface <CODE>java.sql.Statement</CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#addBatch(java.lang.String)">addBatch</A></CODE> in class <CODE><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html" title="class in org.hsqldb.jdbc">jdbcStatement</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sql</CODE> - ignored
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - always<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#executeBatch()"><CODE>jdbcStatement.executeBatch()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="executeQuery(java.lang.String)"><!-- --></A><H3>
executeQuery</H3>
<PRE>
public java.sql.ResultSet <B>executeQuery</B>(java.lang.String&nbsp;sql)
                                throws java.sql.SQLException</PRE>
<DL>
<DD>This method should always throw if called for a PreparedStatement or
 CallableStatment.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>executeQuery</CODE> in interface <CODE>java.sql.Statement</CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#executeQuery(java.lang.String)">executeQuery</A></CODE> in class <CODE><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html" title="class in org.hsqldb.jdbc">jdbcStatement</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sql</CODE> - ignored
<DT><B>Returns:</B><DD>nothing
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - always</DL>
</DD>
</DL>
<HR>

<A NAME="execute(java.lang.String)"><!-- --></A><H3>
execute</H3>
<PRE>
public boolean <B>execute</B>(java.lang.String&nbsp;sql)
                throws java.sql.SQLException</PRE>
<DL>
<DD>This method should always throw if called for a PreparedStatement or
 CallableStatment.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>execute</CODE> in interface <CODE>java.sql.Statement</CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#execute(java.lang.String)">execute</A></CODE> in class <CODE><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html" title="class in org.hsqldb.jdbc">jdbcStatement</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sql</CODE> - ignored
<DT><B>Returns:</B><DD>nothing
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - always<DT><B>See Also:</B><DD><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getResultSet()"><CODE>jdbcStatement.getResultSet()</CODE></A>, 
<A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getUpdateCount()"><CODE>jdbcStatement.getUpdateCount()</CODE></A>, 
<A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#getMoreResults()"><CODE>jdbcStatement.getMoreResults()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="executeUpdate(java.lang.String)"><!-- --></A><H3>
executeUpdate</H3>
<PRE>
public int <B>executeUpdate</B>(java.lang.String&nbsp;sql)
                  throws java.sql.SQLException</PRE>
<DL>
<DD>This method should always throw if called for a PreparedStatement or
 CallableStatment.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>executeUpdate</CODE> in interface <CODE>java.sql.Statement</CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#executeUpdate(java.lang.String)">executeUpdate</A></CODE> in class <CODE><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html" title="class in org.hsqldb.jdbc">jdbcStatement</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sql</CODE> - ignored
<DT><B>Returns:</B><DD>nothing
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - always</DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A><H3>
close</H3>
<PRE>
public void <B>close</B>()
           throws java.sql.SQLException</PRE>
<DL>
<DD>Does the specialized work required to free this object's resources and
 that of it's parent class. <p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>close</CODE> in interface <CODE>java.sql.Statement</CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html#close()">close</A></CODE> in class <CODE><A HREF="../../../org/hsqldb/jdbc/jdbcStatement.html" title="class in org.hsqldb.jdbc">jdbcStatement</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Retrieves a String representation of this object.  <p>

 The representation is of the form: <p>

 class-name@hash[sql=[char-sequence], parameters=[p1, ...pi, ...pn]] <p>

 p1, ...pi, ...pn are the String representations of the currently set
 parameter values that will be used with the non-batch execution
 methods. <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a String representation of this object</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/jdbcPreparedStatement.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/hsqldb/jdbc/jdbcParameterMetaData.html" title="class in org.hsqldb.jdbc"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/hsqldb/jdbc/jdbcResultSet.html" title="class in org.hsqldb.jdbc"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="jdbcPreparedStatement.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<i>Copyright  2001 - 2005 HSQL Development Group. All Rights Reserved.</i>
</BODY>
</HTML>
